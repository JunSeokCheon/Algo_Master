# BOJ_S2_10971_외판원 순회2 [2023-04-28]
https://www.acmicpc.net/problem/10971

<접근법>
```
1. pypy로는 정답이지만 python3로는 시간초과가 난 코드로, permutations를 활용하여 각 경우의수를 모두 계산.
2. 재귀를 활용하여 dfs로 풀이. visited를 사용하여 이미 가본곳이라면 가지 않음 + 만약 이동하려는 도시로의 길이 0이라면(길이 없다면) 가지 않음.
```
```
# - 첫번째 풀이 - 
from itertools import permutations
import sys

input = sys.stdin.readline
n = int(input())

cities = list(range(n))
matrix = []
answer = 1e9

for _ in range(n):
    matrix.append(list(map(int, input().split())))


p = permutations(cities,n)


for val in p:
    start = val[0]
    temp = 0
    #1 -> 2 -> 3 -> 4 -> 1
    for i in range(n-1):
        if matrix[val[i]][val[i+1]] != 0:
            temp += matrix[val[i]][val[i+1]]
        else:
            break
    else:
        if matrix[val[-1]][start] != 0:
            temp += matrix[val[-1]][start]
            answer = min(answer, temp)
print(answer)



# -2-
n = int(input())

matrix = []
visited = [0] * n
answer = 1e9

for _ in range(n):
    matrix.append(list(map(int, input().split())))


def dfs(start, curr, total, depth):
    global answer
    if depth == n:
        if matrix[curr][start]:
            total += matrix[curr][start]
            answer = min(answer, total)
        return

    for i in range(n):
        if not visited[i] and matrix[curr][i]:
            visited[i] = 1
            dfs(start, i, total + matrix[curr][i], depth+1)
            visited[i] = 0


for i in range(n):
    visited[i] = 1
    dfs(i, i, 0, 1)
    visited[i] = 0

print(answer)
```