# BOJ_S2_17086\_아기 상어 2 [2023-03-05]

https://www.acmicpc.net/problem/17086

<접근법>

```
** bfs 탐색 **
1. 0인 모든 좌표에 대해 bfs를 수행
2. bfs를 수행할 때 큐에 이동거리도 함께 담아 최초로 1에 도달할 때의 거리값 리턴
3. 1~2에 대한 max값을 정답으로 갱신

* 더 빠른 시간복잡도로 푸는 방법 ??
1. for문을 돌면서 모든 좌표에 bfs를 수행하지 말고, input을 받으면서 1인 좌표를 모두 큐에 넣어서 bfs 돌림
2. 그래프에 이동거리 값을 할당
3. 그래프 각 좌표에 할당된 값이 가까운 1(상어)로부터의 최단거리이므로 그 값들의 max값을 구함
```

```python
# visited 갱신 위치에 유의하기

import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())

# 안전 거리 = 가장 가까운 1과의 거리

# 1 하우, 2 하좌, 3 상좌, 4 상우, 5 하, 6 상, 7 좌, 8 우
dy = [-1, -1, 1, 1, -1, 1, 0, 0]
dx = [1, -1, -1, 1, 0, 0, -1, 1]

graph = [list(map(int, input().split())) for _ in range(n)]

answer = 0

def bfs(y, x):
    visited = [[False] * m for _ in range(n)]
    q = deque()
    q.append((y, x, 0))

    while q:
        (y, x, dist) = q.popleft()

        # 상어에 최초 도달할 경우 거리 리턴
        if graph[y][x] == 1:
            return dist

        for i in range(8):
            ny = y + dy[i]
            nx = x + dx[i]

            if ny < 0 or nx < 0 or ny >= n or nx >= m:
                continue

            if not visited[ny][nx]:
                q.append((ny, nx, dist+1))
                visited[ny][nx] = True

# 빈칸인 모든 좌표에 대해 bfs
for i in range(n):
    for j in range(m):
        if graph[i][j] == 0:
            # 최댓값 구하기
            answer = max(answer, bfs(i, j))

print(answer)

'''
* 메모리: 34176 KB
* 시간: 3652 ms
'''
```

```python
import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())

# 1 하우, 2 하좌, 3 상좌, 4 상우, 5 하, 6 상, 7 좌, 8 우
dy = [-1, -1, 1, 1, -1, 1, 0, 0]
dx = [1, -1, -1, 1, 0, 0, -1, 1]

graph = []
q = deque()

for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(m):
        if graph[i][j] == 1:
            q.append((i, j))

answer = 0

while q:
    (y, x) = q.popleft()

    for i in range(8):
        ny = y + dy[i]
        nx = x + dx[i]

        if ny < 0 or nx < 0 or ny >= n or nx >= m:
            continue

        if graph[ny][nx] == 0:
            q.append((ny, nx))
            graph[ny][nx] = graph[y][x] + 1
            answer = max(answer, graph[ny][nx])

print(answer-1)

'''
* 메모리: 34176 KB
* 시간: 72 ms
'''
```
