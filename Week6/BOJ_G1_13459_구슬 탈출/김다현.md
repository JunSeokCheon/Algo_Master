import sys
from collections import deque
from pprint import pprint
input = sys.stdin.readline
n,m = map(int, input().split())
arr=[]
rx, ry, bx, by = [0]*4
#Red와 Blue의 탐사여부 체크
check = [[[[False]*m for _ in range(n)] for _ in range(m)] for _ in range(n)]
pprint(check)
q= deque()

for i in range(m):
    arr.append(list(input().strip()))
    for j in range(n):
        if arr[i][j]=='R':
            rx, ry = i,j
        elif arr[i][j]=='B':
            bx, by = i,j
q.append((rx, ry, bx, by,0))
check[rx][ry][bx][by] = True

dy= [0,0,-1,1]
dx= [-1,1,0,0]

def move(x, y, dx, dy, c):
    while arr[x+dx][y+dy] != '#' and arr[x][y] != 'O':
        x+=dx
        y+=dy
        c+=1
    return x,y,c
def bfs():
    while q:
        rx, ry, bx, by, d = q.popleft()
        if d>=10:
            break
        for i in range(4):
            #각자 구슬이 있는데서부터 움직이기 시작
            nrx, nry, rc = move(rx, ry, dx[i],dy[i],0)
            nbx, nby, bc = move(bx, by, dx[i],dy[i],0)
            if arr[nrx][nry]=='O':
                continue #무시하고 다음턴으로
            if arr[nrx][nry]=='O':
                print(1)
                return
            if nrx == nbx and nry ==nby:  #빨강=파랑 좌표 같고
                if rc > bc :#빨강이 더 많이 움직였다면
                    nrx, nry = nrx-dx[i],nry-dy[i] #빨강 원래대로
                else:
                    nbx, nby = nbx-dx[i], nby-dy[i]
            if not check[nrx][nry][nbx][nby]:
                check[nrx][nry][nbx][nby] = True
            q.append((nrx, nry, nbx, nby, d+1))
    print(0)
bfs()
    
            
                
    